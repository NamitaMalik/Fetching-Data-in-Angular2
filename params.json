{
  "name": "Fetching Data In Angular2",
  "tagline": "This blog discusses how to fetch data in Angular2.",
  "body": "# Fetching Data in Angular2\r\n\r\nOne of the most common scenario in any application is **client** interacting with the **server**. **HTTP** is the widely used protocol for this interaction. One can fetch data from the server, update data, create data and delete it using **HTTP** protocol.\r\n\r\nThe focus of this blog is to discuss the **GET** method of **HTTP** protocol.\r\n\r\nIn **Angular1.x**, we used **$http** service which provided us a **get()** method to fetch data from server. A simple **GET** request in **Angular1.x** was something like:\r\n\r\n```JavaScript\r\n$http({method: 'GET', url: '/someUrl'})\r\n    .then(function successCallback(response) {}, \r\n        function errorCallback(response) {}); \r\n```\r\n\r\nAs it can be seen above, **$http** returns a **promise** where we register two callbacks for **success** and **error**.\r\n\r\nNow, let's move on to **Angular2**, and see how stuff works in it. **Angular2** has **Http** service which is used to make **get** calls to server. But an important thing to note here is that though **$http** service in **Angular1.x** returned a **promise**, **Http** service in **Angular2** returns **Observables**.\r\n\r\nSo, before we dive deeper into **Http** service, let's quickly have a glimpse at **Observables**:\r\n\r\nTo start off with, Observables are nothing but a stream of data.These data streams can be of anything - a stream of variables, properties, data structures or\r\neven stream of events. One react to the stream by listening to it. Observables are basically based on **Observer Design Pattern**. In **Observer Design Pattern** one-to-many dependency is maintained between the objects, when one object changes its state all other objects/dependents are notified. These dependents are known as **Observers**.\r\n\r\nA stream can emit 3 different things:\r\n\r\n1. Value\r\n2. Error\r\n3. Completed signal\r\n\r\nSuppose that stream is a stream of events being observed. A function is defined that will be executed when a value is emitted, another function executes when an error is emitted and a third one once the complete signal is emitted.\r\nOne can capture these events by using these functions. These functions are known as **Observers** and the stream which is being emitted is the **Observable**.\r\n\r\n**Observables** can be of two types:\r\n\r\n**1.Hot** - **Hot observables** are those which produce values even before their subscription gets activated. One can consider **Hot Observables** as live performances. The **hot observable** sequence is shared among each **subscriber**, also each **subscriber** gets the next value \r\n in the sequence.\r\n\r\n**2.Cold** - **Cold observables** behave like standard **iterators**. They push values only when we subscribes to them and they reset when we subscribe again. One can consider **Cold Observables** as a movie.\r\n\r\n**Angular2** has chosen **Rxjs** as its core async pattern. **Rxjs** provides a number of operators attached to a stream such as **map**, **filter**, **scan**, **flatMap**, **toPromise**, **catch**.\r\n\r\nWell, the above discussion is not even a tip of the iceberg on a subject such as **Observable**. You can read out more from [here](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) and [here](http://www.barbarianmeetscoding.com/blog/2016/04/11/getting-started-with-rx-dot-js/).\r\n\r\nLet's now move back the original agenda of this blog i.e. fetching data using **Http** service. Here is a sample use case:\r\n\r\n> We need to display a list of posts. The list of posts can be fetched through this API - http://jsonplaceholder.typicode.com/posts/.\r\n\r\nTo achieve the above scenario let's break this small app into parts:\r\n\r\n1. `AppComponent` - This the parent component for our application.\r\n2. `PostsComponent` - This the child component inside our `AppComponent`. It will currently have `PostsListsComponent` as its child component. Tomorrow, if we plan to display the detail of a post, we may add **PostsDetailComponent** to display the details.\r\n3. `PostsData` - We make `PostsData` **interface** to define the type of that we will receive from the **GET** api.\r\n4. `PostsDataService` - This service will actually fetch the data from the **GET** api for us.\r\n\r\nHere is our `app.component.ts`:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostsComponent} from './posts/post.component'\r\n\r\n@Component({\r\n    selector: 'my-app',\r\n    template: `\r\n      <h1>Fetching:</h1>\r\n      <posts-parent></posts-parent>\r\n    `,\r\n    directives:[PostsComponent]\r\n})\r\n\r\nexport class AppComponent {\r\n}\r\n```\r\n   \r\nand here is the `posts.component.ts`:\r\n\r\n```TypeScript\r\nimport {Component}  from '@angular/core';\r\nimport {PostsListsComponent} from './posts-lists.component';\r\nimport {PostsDataService} from './posts-data.service';\r\n   \r\n@Component({\r\n   selector:'posts-parent',\r\n   template:  `\r\n       <h2>View Posts</h2>\r\n       <posts-list></posts-list>\r\n     `,\r\n     directives:[PostsListsComponent],\r\n     providers: [PostsDataService]\r\n})\r\nexport class PostsComponent {\r\n}\r\n```\r\n\r\nWe have injected `PostsDataService`. We register it as a provider by doing `providers:[PostsDataService]` so that its instance is available to all the child components of `PostsComponent`.\r\nIn case you are not aware about the **Angular2** Services, you can have a quick read [Services in Angular2](http://namitamalik.github.io/Services-in-Angular2/)\r\n\r\nLet's see the `posts-data.ts`, where we define the `PostsData`:\r\n\r\n```TypeScript\r\nexport interface PostsData {\r\n    userId:number;\r\n    id:number;\r\n    title:string;\r\n    body:string\r\n}\r\n```\r\n\r\nNow, let's have a look at our `posts-lists.component.ts` which exports the `PostsListsComponent`:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostsDataService} from './posts-data.service';\r\nimport {PostsData} from './posts-data';\r\n\r\n@Component({\r\n    selector:'posts-list',\r\n    template: `\r\n    <div>\r\n    </div>\r\n    `\r\n})\r\n\r\nexport class PostsListsComponent {\r\n    constructor(private _postsDataService: PostsDataService) {\r\n        this.getPosts();\r\n    }\r\n\r\n    private postsData:PostsData[]=[];\r\n    private errorMessage:any='';\r\n\r\n    getPosts() {\r\n        //To Do: Fetch Posts here using PostsDataService\r\n    }\r\n}\r\n```\r\n\r\nCouple of most important tasks are still pending in the above component:\r\n\r\n1. We haven't yet written any code to display the list of posts.\r\n2. We still need to fetch the data from server using the `PostsDataService` i.e. the definition part of the `getPosts()` function.\r\n\r\nSo, let's move to the `posts-data.service.ts` where a lot of action will actually take place:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {PostsData} from './posts-data';\r\n\r\n@Injectable()\r\nexport class PostsDataService {\r\n}\r\n```\r\n\r\nNow, let's start one by one:\r\n\r\n1. First, we need to import **Http** and **Response** from `@angular/http` and also need to import **Observable** from `rxjs/Observable`.\r\nSo our `posts-data.service.ts` would now be:\r\n    ```TypeScript\r\n    import {Injectable} from \"@angular/core\";\r\n    import {PostsData} from './posts-data';\r\n    import { Http, Response } from '@angular/http';\r\n    import { Observable } from 'rxjs/Observable';\r\n    \r\n    @Injectable()\r\n    export class PostsDataService {\r\n    }\r\n    ```\r\n\r\n2. We need to use a few operators in our `getData()` function so we need to import them. Instead of importing all the operators let's import the required ones \r\nin `rxjs-operators.ts` and then import this into our `app.component.ts`. So our `app.component.ts` would now be:\r\n    ```TypeScript\r\n    import {Component} from '@angular/core';\r\n    import {PostsComponent} from './posts/post.component'\r\n    import './rxjs-operators';\r\n    \r\n    @Component({\r\n        selector: 'my-app',\r\n        template: `\r\n          <h1>Fetching:</h1>\r\n          <posts-parent></posts-parent>\r\n        `,\r\n        directives:[PostsComponent]\r\n    })\r\n    \r\n    export class AppComponent {\r\n    }\r\n    ```\r\n\r\n3. Now, we need to have a `getData()` function which will get posts from the api. So here is what our `getData()` function should be like:\r\n    ```TypeScript\r\n    getData (): Observable<PostsData[]> {\r\n       return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n           .map(this.extractData)\r\n           .catch(this.handleError);\r\n    }\r\n    ```\r\n\r\nThe api http://jsonplaceholder.typicode.com/posts/ returns us an array of posts data whereas our `http.get` would return us an **Observable**.\r\nWe then use the **map** operator which transforms the response emitted by Observable by applying a function to it. So in case of success, our flow \r\nwould now move to `extractData()` function, which is:\r\n\r\n```TypeScript\r\nprivate extractData(res: Response) {\r\n    let body = res.json();\r\n    return body || [];\r\n}\r\n```\r\n\r\nIn the above snippet we are transforming are response to the **json** format by doing `res.json()`.\r\n\r\nBut in case, we had encountered error, our flow would have moved to `catch` operator. The **catch** operator intercepts an **onError** notification \r\nfrom **Observable** and continues the sequence without error. `handleError()` function would have come into play in that case:\r\n\r\n```TypeScript\r\nprivate handleError (error: any) {\r\n    let errMsg = (error.message) ? error.message : error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n    return Observable.throw(errMsg);\r\n}\r\n```\r\n\r\nAfter joining all the parts, our `posts-data.services.ts` would look like:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {PostsData} from './posts-data';\r\nimport { Http, Response } from '@angular/http';\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\n@Injectable()\r\nexport class PostsDataService {\r\n    constructor (private http: Http) {}\r\n    getData (): Observable<PostsData[]> {\r\n        return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n            .map(this.extractData)\r\n            .catch(this.handleError);\r\n    }\r\n    private extractData(res: Response) {\r\n        let body = res.json();\r\n        return body || [];\r\n    }\r\n    private handleError (error: any) {\r\n        let errMsg = (error.message) ? error.message : error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n        return Observable.throw(errMsg);\r\n    }\r\n}\r\n```\r\n\r\nWe should note that the above **Observable** is a **cold observable**. So one has to **subscribe** to it.\r\n\r\nNow, let's move back to the `PostsListsComponent` and complete our pending stuff:\r\n\r\n1. We will first add definition part to our `getPosts()` function:\r\n    ```TypeScript\r\n    getPosts() {\r\n        this._postsDataService.getData()\r\n            .subscribe(\r\n                posts => this.postsData=posts,\r\n                error =>  this.errorMessage = <any>error);\r\n    }\r\n    ```    \r\n\r\n    We can see the **subscribe** operator in the above snippet. In **Rxjs** one can **subscribe** to an **Observable** by passing 0 to 3 individual \r\n    functions `onNext`, `onError` and `onCompleted`.\r\n\r\n2. Now, we need to display the fetched `posts` in this `PostsListsComponent`. So our template would like:\r\n    ```HTML\r\n    <div>\r\n        <ul class=\"items\">\r\n        <li *ngFor=\"let postData of postsData\">\r\n        <span>{{postData.title}}</span></li>\r\n        </ul>\r\n    </div>\r\n```    \r\n\r\nIn case you are not aware about how to iterate over **Arrays**, **Map**, **Set** you can have a quick read [here](http://namitamalik.github.io/NgRepeat-vs-ngFor/).\r\n\r\nSo now our complete `PostsListsComponent` would look like:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostsDataService} from './posts-data.service';\r\nimport {PostsData} from './posts-data';\r\n\r\n@Component({\r\n    selector:'posts-list',\r\n    template: `\r\n    <div>\r\n        <ul class=\"items\">\r\n        <li *ngFor=\"let postData of postsData\">\r\n        <span>{{postData.title}}</span></li>\r\n        </ul>\r\n    </div>\r\n    `\r\n})\r\n\r\nexport class PostsListsComponent {\r\n    constructor(private _postsDataService: PostsDataService) {\r\n        this.getPosts();\r\n    }\r\n\r\n    private postsData:PostsData[]=[];\r\n    private errorMessage:any='';\r\n\r\n    getPosts() {\r\n        this._postsDataService.getData()\r\n            .subscribe(\r\n                posts => this.postsData=posts,\r\n                error =>  this.errorMessage = <any>error);\r\n    }\r\n}\r\n```\r\n\r\nWe have completed all the pending stuff and now we should be able to see list of posts.\r\n\r\nBut before we end this post, let's have a look at one for operator i.e. **toPromise**. This **operator** converts an **Observable** \r\nsequence to a **promise**. So if we use promises, then our `posts-data.service.ts` would look like:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {PostsData} from './posts-data';\r\nimport { Http, Response } from '@angular/http';\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\n@Injectable()\r\nexport class PostsDataService {\r\n    constructor (private http: Http) {}\r\n    getData (): Promise<PostsData[]> {\r\n        return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n            .toPromise()\r\n            .then(this.extractData)\r\n            .catch(this.handleError);\r\n    }\r\n    private extractData(res: Response) {\r\n        let body = res.json();\r\n        return body || [];\r\n    }\r\n    private handleError (error: any) {\r\n        // In a real world app, we might use a remote logging infrastructure\r\n        // We'd also dig deeper into the error to get a better message\r\n        let errMsg = (error.message) ? error.message :\r\n            error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n        console.error(errMsg); // log to console instead\r\n        return Observable.throw(errMsg);\r\n    }\r\n}\r\n```\r\n\r\nIf you could notice the difference, we have moved `this.extractData` which is the **success callback** as the first parameter whereas `this.errorHandler` is the second parameter.\r\n\r\nSince we are now using **promises** we will also have to make tweaks in `posts-lists.component.ts`. We will have to call `then` on the  returned promise instead of `subscribe`.\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostsDataService} from './posts-data.service';\r\nimport {PostsData} from './posts-data';\r\n\r\n@Component({\r\n    selector:'posts-list',\r\n    template: `\r\n    <div>\r\n        <ul class=\"items\">\r\n        <li *ngFor=\"let postData of postsData\">\r\n        <span>{{postData.title}}</span></li>\r\n        </ul>\r\n    </div>\r\n    `\r\n})\r\n\r\nexport class PostsListsComponent {\r\n    constructor(private _postsDataService: PostsDataService) {\r\n        this.getPosts();\r\n    }\r\n\r\n    private postsData:PostsData[]=[];\r\n    private errorMessage:any='';\r\n\r\n    getPosts() {\r\n        this._postsDataService.getData()\r\n            .then(\r\n                posts => this.postsData=posts,\r\n                error =>  this.errorMessage = <any>error);\r\n    }\r\n}\r\n```\r\n\r\nAs promised this blog educated us on fetching data in **Angular2** We are yet to see how to post data to a server in **Angular2** so stay tuned! till then Happy Learning!\r\n\r\nFollow Me\r\n---\r\n[Github](https://github.com/NamitaMalik)\r\n\r\n[Twitter](https://twitter.com/namita13_04)\r\n\r\n[LinkedIn](https://in.linkedin.com/in/namita-malik-a7885b23)\r\n\r\n[More Blogs By Me](https://namitamalik.github.io/)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}