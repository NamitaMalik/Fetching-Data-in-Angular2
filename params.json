{
  "name": "Fetching Data In Angular2",
  "tagline": "This blog discusses how to fetch data in Angular2.",
  "body": "# Fetching Data in Angular2\r\n\r\nOne of the most common scenario in any application is **client** interacting with the **server**. **HTTP** is the widely used protocol for this interaction. One can fetch data from the server, update data, create data and delete it using **HTTP** protocol.\r\n\r\nThe focus of this blog is to discuss the **GET** method of **HTTP** protocol.\r\n\r\nIn **Angular1.x**, we used **$http** service which provided us a **get()** method to fetch data from server. A simple **GET** request in **Angular1.x** was something like:\r\n\r\n```JavaScript\r\n$http({method: 'GET', url: '/someUrl'})\r\n    .then(function successCallback(response) {}, \r\n        function errorCallback(response) {}); \r\n```\r\n\r\nAs it can be seen above, **$http** returns a **promise** where we register two callbacks for **success** and **error**.\r\n\r\nNow, let's move on to **Angular2**, and see how stuff works in it. **Angular2** has **Http** service which is used to make **get** calls to server. But an important thing to note here is that **$http** service in **Angular1.x** returned a **promise** while  **Http** service in **Angular2** returns **Observables**.\r\n\r\nSo, before we dive deeper into **Http** service, let's quickly have a glimpse at **Observables**:\r\n\r\nTo start off with, **Observables** are nothing but a stream of data.These data streams can be of anything - a stream of variables, properties, data structures or\r\neven stream of events. One can react to the stream by listening to it. **Observables** are basically based on **Observer Design Pattern**. In **Observer Design Pattern** one-to-many dependency is maintained between the objects, when one object changes its state all other objects/dependents are notified. These dependents are known as **Observers**.\r\n\r\nA stream can emit 3 different things:\r\n\r\n1. Value\r\n2. Error\r\n3. Completed signal\r\n\r\nSuppose that stream is a stream of events being observed. A function is defined that will be executed when a value is emitted, another function executes when an error is emitted and a third one once the complete signal is emitted.\r\nOne can capture these events by using these functions. These functions are known as **Observers** and the stream which is being emitted is the **Observable**.\r\n\r\n**Observables** can be of two types:\r\n\r\n**1.Hot** - **Hot observables** are those which produce values even before their subscription gets activated. One can consider **Hot Observables** as live performance. The **hot observable** sequence is shared among each **subscriber**, also each **subscriber** gets the next value \r\n in the sequence.\r\n\r\n**2.Cold** - **Cold observables** behave like standard **iterators**. They push values only when we subscribes to them and they reset when we subscribe again. One can consider **Cold Observables** as a movie.\r\n\r\n**Angular2** has chosen **Rxjs** as its core async pattern. **Rxjs** provides a number of operators attached to a stream such as **map**, **filter**, **scan**, **flatMap**, **toPromise**, **catch**.\r\n\r\nWell, the above discussion is not even a tip of the iceberg on a subject such as **Observable**. You can read out more from [here](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) and [here](http://www.barbarianmeetscoding.com/blog/2016/04/11/getting-started-with-rx-dot-js/).\r\n\r\nLet's now move back the original agenda of this blog i.e. fetching data using **Http** service. Here is a sample use case:\r\n\r\n> We need to display a list of posts. The list of posts can be fetched through this API - http://jsonplaceholder.typicode.com/posts/.\r\n\r\nTo achieve the above scenario let's break this small app into parts:\r\n\r\n1. `AppComponent` - This is parent component for our application.\r\n2. `PostComponent` - This is child component inside our `AppComponent`. It will currently have `PostListComponent` as its child component. Tomorrow, if we plan to display the detail of a post, we may add **PostDetailComponent** to display the details.\r\n3. `Post` - We make `Post` **interface** to define the type of element that we will receive from the **GET** api.\r\n4. `PostService` - This service will actually fetch the data via making **GET** call on the api for us.\r\n\r\nHere is our `app.component.ts`:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostComponent} from './post/post.component'\r\nimport './rxjs-operators';\r\n\r\n@Component({\r\n    selector: 'my-app',\r\n    template: `\r\n        <h1>Fetching:</h1>\r\n        <post-parent></post-parent>\r\n    `,\r\n    directives: <any>[PostComponent]\r\n})\r\n\r\nexport class AppComponent {\r\n}\r\n```\r\n   \r\nand here is the `post.component.ts`:\r\n\r\n```TypeScript\r\nimport {Component}  from '@angular/core';\r\nimport {PostListComponent} from './post-list.component';\r\nimport {PostService} from './post.service';\r\n\r\n@Component({\r\n    selector: 'post-parent',\r\n    template: `\r\n        <h2>View Posts</h2>\r\n        <post-list></post-list>\r\n    `,\r\n    directives: <any>[PostListComponent],\r\n    providers: <any>[PostService]\r\n})\r\nexport class PostComponent {\r\n}\r\n```\r\n\r\nWe have injected `PostService`. We register it as a provider by doing `providers:[PostService]` so that its instance is available to all the child components of `PostComponent`.\r\nIn case you are not aware about the **Angular2** **Services**, you can have a quick read [Services in Angular2](http://namitamalik.github.io/Services-in-Angular2/).\r\n\r\nLet's see the `post.ts`, where we define the `Post`:\r\n\r\n```TypeScript\r\nexport interface Post {\r\n    userId:number;\r\n    id:number;\r\n    title:string;\r\n    body:string\r\n}\r\n```\r\n\r\nNow, let's have a look at our `post-list.component.ts` which exports the `PostListComponent`:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostService} from './post.service';\r\nimport {Post} from './post';\r\n\r\n@Component({\r\n    selector: 'post-list',\r\n    template: `\r\n        <div>\r\n        </div>\r\n    `\r\n})\r\n\r\nexport class PostListComponent {\r\n    constructor(private _postDataService:PostService) {\r\n        this.getPosts();\r\n    }\r\n\r\n    private posts:Post[] = [];\r\n    private errorMessage:any = '';\r\n\r\n    getPosts() {\r\n        //To Do: Fetch Posts here using PostsDataService\r\n    }\r\n}\r\n```\r\n\r\nCouple of most important tasks are still pending in the above component:\r\n\r\n1. We haven't yet written any code to display the list of post.\r\n2. We still need to fetch the data from server using the `PostService` i.e. the definition part of the `getPosts()` function.\r\n\r\nSo, let's move to the `post.service.ts` where a lot of action will actually take place:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {Post} from './post';\r\n\r\n@Injectable()\r\nexport class PostService {\r\n}\r\n```\r\n\r\nNow, let's start one by one:\r\n\r\n1. First, we need to import **Http** and **Response** from `@angular/http` and also need to import **Observable** from `rxjs/Observable`.\r\nSo our `post.service.ts` would now be:\r\n    ```TypeScript\r\n    import {Injectable} from \"@angular/core\";\r\n    import {Post} from './post';\r\n    import { Http, Response } from '@angular/http';\r\n    import { Observable } from 'rxjs/Observable';\r\n    \r\n    @Injectable()\r\n    export class PostService {\r\n    }\r\n    ```\r\n\r\n2. We need to use a few operators in our `getData()` function so we need to import them. Instead of importing all the operators let's import the required ones \r\nin `rxjs-operators.ts` and then import this into our `app.component.ts`.\r\n\r\n    **rxjs-operators.ts**:\r\n    ```TypeScript\r\n    import 'rxjs/add/operator/catch';\r\n    import 'rxjs/add/operator/map';\r\n    import 'rxjs/add/operator/toPromise';\r\n    ```\r\n    \r\n    **app.components.ts**:\r\n    ```TypeScript\r\n    import {Component} from '@angular/core';\r\n    import {PostComponent} from './post/post.component'\r\n    import './rxjs-operators';\r\n    \r\n    @Component({\r\n        selector: 'my-app',\r\n        template: `\r\n          <h1>Fetching:</h1>\r\n          <post-parent></post-parent>\r\n        `,\r\n        directives:[PostComponent]\r\n    })\r\n    \r\n    export class AppComponent {\r\n    }\r\n    ```\r\n\r\n3. Now, we need to have a `getData()` function which will get posts from the api. So here is what our `getData()` function should be like:\r\n    ```TypeScript\r\n    getData():Observable<Post[]> {\r\n        return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n            .map(this.extractData)\r\n            .catch(this.handleError);\r\n    }\r\n    ```\r\n\r\nThe api http://jsonplaceholder.typicode.com/posts/ returns us an array of post whereas our `http.get` would return us an **Observable**.\r\nWe then use the **map** operator which transforms the response emitted by **Observable** by applying a function to it. So in case of success, our flow \r\nwould now move to `extractData()` function, which is:\r\n\r\n```TypeScript\r\nprivate extractData(res:Response) {\r\n    let body = res.json();\r\n    return body || [];\r\n}\r\n```\r\n\r\nIn the above snippet we are transforming response to the **json** format by doing `res.json()`.\r\n\r\nBut in case had we encountered an error, our flow would have moved to `catch` operator. The **catch** operator intercepts an **onError** notification \r\nfrom **Observable** and continues the sequence without error. `handleError()` function would have come into play in that case:\r\n\r\n```TypeScript\r\nprivate handleError(error:any) {\r\n    // In a real world app, we might use a remote logging infrastructure\r\n    // We'd also dig deeper into the error to get a better message\r\n    let errMsg = (error.message) ? error.message :\r\n        error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n    console.error(errMsg); // log to console instead\r\n    return Observable.throw(errMsg);\r\n}\r\n```\r\n\r\nAfter joining all the parts, our `post.service.ts` would look like:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {Http, Response} from '@angular/http';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Post} from './post';\r\n\r\n@Injectable()\r\nexport class PostService {\r\n    constructor(private http:Http) {\r\n    }\r\n\r\n    getData():Observable<Post[]> {\r\n        return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n            .map(this.extractData)\r\n            .catch(this.handleError);\r\n    }\r\n\r\n    private extractData(res:Response) {\r\n        let body = res.json();\r\n        return body || [];\r\n    }\r\n\r\n    private handleError(error:any) {\r\n        // In a real world app, we might use a remote logging infrastructure\r\n        // We'd also dig deeper into the error to get a better message\r\n        let errMsg = (error.message) ? error.message :\r\n            error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n        console.error(errMsg); // log to console instead\r\n        return Observable.throw(errMsg);\r\n    }\r\n}\r\n```\r\n\r\nWe should note that the above **Observable** is a **cold observable**. So one has to **subscribe** to it.\r\n\r\nNow, let's move back to the `PostListComponent` and complete our pending stuff:\r\n\r\n1. We will first add definition part to our `getPosts()` function:\r\n    ```TypeScript\r\n    getPosts() {\r\n        this._postDataService.getData()\r\n            .subscribe(\r\n                posts => this.posts = posts,\r\n                error => this.errorMessage = <any>error);\r\n    }\r\n    ```    \r\n\r\n    We can see the **subscribe** operator in the above snippet. In **Rxjs** one can **subscribe** to an **Observable** by passing 0 to 3 individual \r\n    functions `onNext`, `onError` and `onCompleted`.\r\n\r\n2. Now, we need to display the fetched `post` in this `PostListComponent`. So our template would like:\r\n    ```HTML\r\n    <div>\r\n        <ul class=\"items\">\r\n            <li *ngFor=\"let post of posts\">\r\n                <span>{{post.title}}</span>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n    ```    \r\n\r\nIn case you are not aware about how to iterate over **Arrays**, **Map**, **Set** you can have a quick read [here](http://namitamalik.github.io/NgRepeat-vs-ngFor/).\r\n\r\nSo now our complete `PostListComponent` would look like:\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostService} from './post.service';\r\nimport {Post} from './post';\r\n\r\n@Component({\r\n    selector: 'post-list',\r\n    template: `\r\n        <div>\r\n            <ul class=\"items\">\r\n                <li *ngFor=\"let post of posts\">\r\n                    <span>{{post.title}}</span>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    `\r\n})\r\n\r\nexport class PostListComponent {\r\n    constructor(private _postDataService:PostService) {\r\n        //should be moved to ngOnInit lifecycle hook\r\n        this.getPosts();\r\n    }\r\n\r\n    private posts:Post[] = [];\r\n    private errorMessage:any = '';\r\n\r\n    getPosts() {\r\n        this._postDataService.getData()\r\n            .subscribe(\r\n                posts => this.posts = posts,\r\n                error => this.errorMessage = <any>error);\r\n    }\r\n}\r\n```\r\n\r\n> It is important to note that though we have called `getPosts` function in constructor, it is not a good practice. We should have called it in the **ngOnInit** lifecycle hook. Our constructors should be simple to enable easy debugging and testing.\r\n\r\nWe have completed all the pending stuff and now we should be able to see list of post.\r\n\r\nBut before we end this post, let's have a look at one more operator i.e. **toPromise**. This **operator** converts an **Observable** \r\nsequence to a **promise**. So if we use promises, then our `post.service.ts` would look like:\r\n\r\n```TypeScript\r\nimport {Injectable} from \"@angular/core\";\r\nimport {Post} from './post';\r\nimport { Http, Response } from '@angular/http';\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\n@Injectable()\r\nexport class PostService {\r\n    constructor (private http: Http) {}\r\n    getData (): Promise<Post[]> {\r\n        return this.http.get('http://jsonplaceholder.typicode.com/posts/')\r\n            .toPromise()\r\n            .then(this.extractData)\r\n            .catch(this.handleError);\r\n    }\r\n    private extractData(res: Response) {\r\n        let body = res.json();\r\n        return body || [];\r\n    }\r\n    private handleError (error: any) {\r\n        // In a real world app, we might use a remote logging infrastructure\r\n        // We'd also dig deeper into the error to get a better message\r\n        let errMsg = (error.message) ? error.message :\r\n            error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n        console.error(errMsg); // log to console instead\r\n        return Observable.throw(errMsg);\r\n    }\r\n}\r\n```\r\n\r\nIf you could notice the difference, we have moved `this.extractData` which is the **success callback** as the first parameter whereas `this.errorHandler` is the second parameter.\r\n\r\nSince we are now using **promises** we will also have to make tweaks in `post-list.component.ts`. We will have to call `then` on the returned promise instead of `subscribe`.\r\n\r\n```TypeScript\r\nimport {Component} from '@angular/core';\r\nimport {PostService} from './post.service';\r\nimport {Post} from './post';\r\n\r\n@Component({\r\n    selector: 'post-list',\r\n    template: `\r\n        <div>\r\n            <ul class=\"items\">\r\n                <li *ngFor=\"let post of posts\">\r\n                    <span>{{post.title}}</span>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    `\r\n})\r\n\r\nexport class PostListComponent {\r\n    constructor(private _postDataService:PostService) {\r\n        this.getPosts();\r\n    }\r\n\r\n    private posts:Post[] = [];\r\n    private errorMessage:any = '';\r\n\r\n    getPosts() {\r\n        this._postDataService.getData()\r\n            .then(\r\n                posts => this.posts = posts,\r\n                error => this.errorMessage = <any>error);\r\n    }\r\n}\r\n```\r\n\r\nAs promised this blog educated us on fetching data in **Angular2** We are yet to see how to post data to a server in **Angular2** so stay tuned! Till then Happy Learning!\r\n\r\nFollow Me\r\n---\r\n[Github](https://github.com/NamitaMalik)\r\n\r\n[Twitter](https://twitter.com/namita13_04)\r\n\r\n[LinkedIn](https://in.linkedin.com/in/namita-malik-a7885b23)\r\n\r\n[More Blogs By Me](https://namitamalik.github.io/)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}